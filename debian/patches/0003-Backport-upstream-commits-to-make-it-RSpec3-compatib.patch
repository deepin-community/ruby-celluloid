From: Hleb Valoshka <375gnu@gmail.com>
Date: Fri, 26 Jun 2015 16:46:53 +0300
Subject: Backport upstream commits to make it RSpec3 compatibile

  Upstream commits taken: 785d0312, 5afbc528, b9bd03a2, e143921c, 715911d9,
  2dfd26fe, 30465222, 00068840, ccc009c7, 380016ee.
---
 lib/celluloid/rspec/actor_examples.rb      | 268 ++++++++++++++---------------
 lib/celluloid/rspec/mailbox_examples.rb    |  30 ++--
 lib/celluloid/rspec/task_examples.rb       |   8 +-
 spec/celluloid/actor_system_spec.rb        |  24 +--
 spec/celluloid/block_spec.rb               |   2 +-
 spec/celluloid/calls_spec.rb               |   6 +-
 spec/celluloid/condition_spec.rb           |  20 +--
 spec/celluloid/cpu_counter_spec.rb         |  37 ++--
 spec/celluloid/fsm_spec.rb                 |  22 +--
 spec/celluloid/future_spec.rb              |   8 +-
 spec/celluloid/internal_pool_spec.rb       |  30 ++--
 spec/celluloid/links_spec.rb               |  12 +-
 spec/celluloid/logging/ring_buffer_spec.rb |  20 +--
 spec/celluloid/notifications_spec.rb       |  18 +-
 spec/celluloid/pool_spec.rb                |  22 +--
 spec/celluloid/probe_spec.rb               |  12 +-
 spec/celluloid/properties_spec.rb          |  18 +-
 spec/celluloid/registry_spec.rb            |  18 +-
 spec/celluloid/stack_dump_spec.rb          |  21 ++-
 spec/celluloid/supervision_group_spec.rb   |  14 +-
 spec/celluloid/supervisor_spec.rb          |  40 ++---
 spec/celluloid/thread_handle_spec.rb       |   6 +-
 spec/celluloid/uuid_spec.rb                |   2 +-
 23 files changed, 333 insertions(+), 325 deletions(-)

diff --git a/lib/celluloid/rspec/actor_examples.rb b/lib/celluloid/rspec/actor_examples.rb
index c075072..58e0771 100644
--- a/lib/celluloid/rspec/actor_examples.rb
+++ b/lib/celluloid/rspec/actor_examples.rb
@@ -16,32 +16,32 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
   it "returns the actor's class, not the proxy's" do
     actor = actor_class.new "Troy McClure"
-    actor.class.should eq(actor_class)
+    expect(actor.class).to eq(actor_class)
   end
 
   it "compares with the actor's class in a case statement" do
-    case actor_class.new("Troy McClure")
+    expect(case actor_class.new("Troy McClure")
     when actor_class
       true
     else
       false
-    end.should be_true
+    end).to be_truthy
   end
 
   it "can be stored in hashes" do
     actor = actor_class.new "Troy McClure"
-    actor.hash.should_not eq(Kernel.hash)
-    actor.object_id.should_not eq(Kernel.object_id)
+    expect(actor.hash).not_to eq(Kernel.hash)
+    expect(actor.object_id).not_to eq(Kernel.object_id)
   end
 
   it "implements respond_to? correctly" do
     actor = actor_class.new 'Troy McClure'
-    actor.should respond_to(:alive?)
+    expect(actor).to respond_to(:alive?)
   end
 
   it "supports synchronous calls" do
     actor = actor_class.new "Troy McClure"
-    actor.greet.should eq("Hi, I'm Troy McClure")
+    expect(actor.greet).to eq("Hi, I'm Troy McClure")
   end
 
   it "supports synchronous calls with blocks" do
@@ -49,45 +49,45 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
     block_executed = false
     actor.run { block_executed = true }
-    block_executed.should be_true
+    expect(block_executed).to be_truthy
   end
 
   it "supports synchronous calls via #method" do
     method = actor_class.new("Troy McClure").method(:greet)
-    method.call.should eq("Hi, I'm Troy McClure")
+    expect(method.call).to eq("Hi, I'm Troy McClure")
   end
 
   it "supports #arity calls via #method" do
     method = actor_class.new("Troy McClure").method(:greet)
-    method.arity.should be(0)
+    expect(method.arity).to be(0)
 
     method = actor_class.new("Troy McClure").method(:change_name)
-    method.arity.should be(1)
+    expect(method.arity).to be(1)
   end
 
   it "supports #name calls via #method" do
     method = actor_class.new("Troy McClure").method(:greet)
-    method.name.should == :greet
+    expect(method.name).to eq(:greet)
   end
 
   it "supports #parameters via #method" do
     method = actor_class.new("Troy McClure").method(:greet)
-    method.parameters.should == []
+    expect(method.parameters).to eq([])
 
     method = actor_class.new("Troy McClure").method(:change_name)
-    method.parameters.should == [[:req, :new_name]]
+    expect(method.parameters).to eq([[:req, :new_name]])
   end
 
   it "supports future(:method) syntax for synchronous future calls" do
     actor = actor_class.new "Troy McClure"
     future = actor.future :greet
-    future.value.should eq("Hi, I'm Troy McClure")
+    expect(future.value).to eq("Hi, I'm Troy McClure")
   end
 
   it "supports future.method syntax for synchronous future calls" do
     actor = actor_class.new "Troy McClure"
     future = actor.future.greet
-    future.value.should eq("Hi, I'm Troy McClure")
+    expect(future.value).to eq("Hi, I'm Troy McClure")
   end
 
   it "handles circular synchronous calls" do
@@ -106,7 +106,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
     ponycopter = klass.new
     actor = actor_class.new ponycopter
-    ponycopter.greet_by_proxy(actor).should eq("Hi, I'm a ponycopter!")
+    expect(ponycopter.greet_by_proxy(actor)).to eq("Hi, I'm a ponycopter!")
   end
 
   it "detects recursion" do
@@ -135,20 +135,20 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     actor1 = klass1.new
     actor2 = klass2.new
 
-    actor1.recursion_test.should be_false
-    actor1.recursion_test(actor2).should be_true
+    expect(actor1.recursion_test).to be_falsey
+    expect(actor1.recursion_test(actor2)).to be_truthy
   end
 
   it "properly handles method_missing" do
     actor = actor_class.new "Method Missing"
-    actor.should respond_to(:first)
-    actor.first.should be :bar
+    expect(actor).to respond_to(:first)
+    expect(actor.first).to be :bar
   end
 
   it "properly handles respond_to with include_private" do
     actor = actor_class.new "Method missing privates"
-    actor.respond_to?(:zomg_private).should be_false
-    actor.respond_to?(:zomg_private, true).should be_true
+    expect(actor.respond_to?(:zomg_private)).to be_falsey
+    expect(actor.respond_to?(:zomg_private, true)).to be_truthy
   end
 
   it "warns about suspending the initialize" do
@@ -161,7 +161,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end
     end
 
-    Celluloid.logger.should_receive(:warn).with(/Dangerously suspending task: type=:call, meta={:method_name=>:initialize}, status=:sleeping/)
+    expect(Celluloid.logger).to receive(:warn).with(/Dangerously suspending task: type=:call, meta={:method_name=>:initialize}, status=:sleeping/)
 
     actor = klass.new
     actor.terminate
@@ -170,7 +170,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
   it "calls the user defined finalizer" do
     actor = actor_class.new "Mr. Bean"
-    actor.wrapped_object.should_receive(:my_finalizer)
+    expect(actor.wrapped_object).to receive(:my_finalizer)
     actor.terminate
     Celluloid::Actor.join(actor)
   end
@@ -187,7 +187,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end
     end
 
-    Celluloid.logger.should_receive(:warn).with(/Dangerously suspending task: type=:finalizer, meta={:method_name=>:cleanup}, status=:sleeping/)
+    expect(Celluloid.logger).to receive(:warn).with(/Dangerously suspending task: type=:finalizer, meta={:method_name=>:cleanup}, status=:sleeping/)
 
     actor = klass.new
     actor.terminate
@@ -197,53 +197,53 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
   it "supports async(:method) syntax for asynchronous calls" do
     actor = actor_class.new "Troy McClure"
     actor.async :change_name, "Charlie Sheen"
-    actor.greet.should eq("Hi, I'm Charlie Sheen")
+    expect(actor.greet).to eq("Hi, I'm Charlie Sheen")
   end
 
   it "supports async.method syntax for asynchronous calls" do
     actor = actor_class.new "Troy McClure"
     actor.async.change_name "Charlie Sheen"
-    actor.greet.should eq("Hi, I'm Charlie Sheen")
+    expect(actor.greet).to eq("Hi, I'm Charlie Sheen")
   end
 
   it "supports async.method syntax for asynchronous calls to itself" do
     actor = actor_class.new "Troy McClure"
     actor.change_name_async "Charlie Sheen"
-    actor.greet.should eq("Hi, I'm Charlie Sheen")
+    expect(actor.greet).to eq("Hi, I'm Charlie Sheen")
   end
 
   it "allows an actor to call private methods asynchronously" do
     actor = actor_class.new "Troy McClure"
     actor.call_private
-    actor.private_called.should be_true
+    expect(actor.private_called).to be_truthy
   end
 
   it "knows if it's inside actor scope" do
-    Celluloid.should_not be_actor
+    expect(Celluloid).not_to be_actor
     actor = actor_class.new "Troy McClure"
-    actor.run do
+    expect(actor.run do
       Celluloid.actor?
-    end.should be_false
-    actor.run_on_receiver do
+    end).to be_falsey
+    expect(actor.run_on_receiver do
       Celluloid.actor?
-    end.should be_true
-    actor.should be_actor
+    end).to be_truthy
+    expect(actor).to be_actor
   end
 
   it "inspects properly" do
     actor = actor_class.new "Troy McClure"
-    actor.inspect.should match(/Celluloid::CellProxy\(/)
-    actor.inspect.should match(/#{actor_class}/)
-    actor.inspect.should include('@name="Troy McClure"')
-    actor.inspect.should_not include("@celluloid")
+    expect(actor.inspect).to match(/Celluloid::CellProxy\(/)
+    expect(actor.inspect).to match(/#{actor_class}/)
+    expect(actor.inspect).to include('@name="Troy McClure"')
+    expect(actor.inspect).not_to include("@celluloid")
   end
 
   it "inspects properly when dead" do
     actor = actor_class.new "Troy McClure"
     actor.terminate
-    actor.inspect.should match(/Celluloid::CellProxy\(/)
-    actor.inspect.should match(/#{actor_class}/)
-    actor.inspect.should include('dead')
+    expect(actor.inspect).to match(/Celluloid::CellProxy\(/)
+    expect(actor.inspect).to match(/#{actor_class}/)
+    expect(actor.inspect).to include('dead')
   end
 
   it "supports recursive inspect with other actors" do
@@ -263,26 +263,26 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     itchy.other = scratchy
 
     inspection = itchy.inspect
-    inspection.should match(/Celluloid::CellProxy\(/)
-    inspection.should include("...")
+    expect(inspection).to match(/Celluloid::CellProxy\(/)
+    expect(inspection).to include("...")
   end
 
   it "allows access to the wrapped object" do
     actor = actor_class.new "Troy McClure"
-    actor.wrapped_object.should be_a actor_class
+    expect(actor.wrapped_object).to be_a actor_class
   end
 
   it "warns about leaked wrapped objects via #inspect" do
     actor = actor_class.new "Troy McClure"
 
-    actor.inspect.should_not include Celluloid::BARE_OBJECT_WARNING_MESSAGE
-    actor.inspect_thunk.should_not include Celluloid::BARE_OBJECT_WARNING_MESSAGE
-    actor.wrapped_object.inspect.should include Celluloid::BARE_OBJECT_WARNING_MESSAGE
+    expect(actor.inspect).not_to include Celluloid::BARE_OBJECT_WARNING_MESSAGE
+    expect(actor.inspect_thunk).not_to include Celluloid::BARE_OBJECT_WARNING_MESSAGE
+    expect(actor.wrapped_object.inspect).to include Celluloid::BARE_OBJECT_WARNING_MESSAGE
   end
 
   it "can override #send" do
     actor = actor_class.new "Troy McClure"
-    actor.send('foo').should eq('oof')
+    expect(actor.send('foo')).to eq('oof')
   end
 
   context "when executing under JRuby" do
@@ -302,11 +302,11 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     }
 
     it "sets execution info" do
-      klass.new.current_thread_name.should == "Class#current_thread_name"
+      expect(klass.new.current_thread_name).to eq("Class#current_thread_name")
     end
 
     it "unsets execution info after task completion" do
-      klass.new.java_thread.get_name.should == "<unused>"
+      expect(klass.new.java_thread.get_name).to eq("<unused>")
     end
   end if RUBY_PLATFORM == "java"
 
@@ -314,15 +314,15 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     let(:actor) { actor_class.new "Troy McClure" }
 
     before do
-      actor.wrapped_object.should_receive(:external_hello).once.and_return "World"
+      expect(actor.wrapped_object).to receive(:external_hello).once.and_return "World"
     end
 
     it "works externally via the proxy" do
-      actor.external_hello.should eq("World")
+      expect(actor.external_hello).to eq("World")
     end
 
     it "works internally when called on self" do
-      actor.internal_hello.should eq("World")
+      expect(actor.internal_hello).to eq("World")
     end
   end
 
@@ -360,9 +360,9 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       rescue => ex
       end
 
-      ex.should be_a ExampleCrash
-      ex.backtrace.grep(/`sender_method'/).should be_true
-      ex.backtrace.grep(/`receiver_method'/).should be_true
+      expect(ex).to be_a ExampleCrash
+      expect(ex.backtrace.grep(/`sender_method'/)).to be_truthy
+      expect(ex.backtrace.grep(/`receiver_method'/)).to be_truthy
     end
 
     it "raises DeadActorError if methods are synchronously called on a dead actor" do
@@ -385,7 +385,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
         actor.crash_with_abort "You die motherfucker!", :bar
       end.to raise_exception(ExampleCrash, "You die motherfucker!")
 
-      actor.should be_alive
+      expect(actor).to be_alive
     end
 
     it "converts strings to runtime errors" do
@@ -402,33 +402,33 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end.to raise_exception(TypeError, "Exception object/String expected, but Fixnum received")
 
       Celluloid::Actor.join(actor)
-      actor.should_not be_alive
+      expect(actor).not_to be_alive
     end
   end
 
   context :termination do
     it "terminates" do
       actor = actor_class.new "Arnold Schwarzenegger"
-      actor.should be_alive
+      expect(actor).to be_alive
       actor.terminate
       Celluloid::Actor.join(actor)
-      actor.should_not be_alive
+      expect(actor).not_to be_alive
     end
 
     it "can be terminated by a SyncCall" do
       actor = actor_class.new "Arnold Schwarzenegger"
-      actor.should be_alive
+      expect(actor).to be_alive
       actor.shutdown
       Celluloid::Actor.join(actor)
-      actor.should_not be_alive
+      expect(actor).not_to be_alive
     end
 
     it "kills" do # THOU SHALT ALWAYS KILL
       actor = actor_class.new "Woody Harrelson"
-      actor.should be_alive
+      expect(actor).to be_alive
       Celluloid::Actor.kill(actor)
       Celluloid::Actor.join(actor)
-      actor.should_not be_alive
+      expect(actor).not_to be_alive
     end
 
     it "raises DeadActorError if called after terminated" do
@@ -441,12 +441,12 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "terminates cleanly on Celluloid shutdown" do
-      Celluloid::Actor.stub(:kill).and_call_original
+      allow(Celluloid::Actor).to receive(:kill).and_call_original
 
       actor = actor_class.new "Arnold Schwarzenegger"
 
       Celluloid.shutdown
-      Celluloid::Actor.should_not have_received(:kill)
+      expect(Celluloid::Actor).not_to have_received(:kill)
     end
 
     it "raises the right DeadActorError if terminate! called after terminated" do
@@ -459,7 +459,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "logs a warning when terminating tasks" do
-      Celluloid.logger.should_receive(:warn).with(/^Terminating task: type=:call, meta={:method_name=>:sleepy}, status=:sleeping\n/)
+      expect(Celluloid.logger).to receive(:warn).with(/^Terminating task: type=:call, meta={:method_name=>:sleepy}, status=:sleeping\n/)
 
       actor = actor_class.new "Arnold Schwarzenegger"
       actor.async.sleepy 10
@@ -472,7 +472,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
   context :current_actor do
     it "knows the current actor" do
       actor = actor_class.new "Roger Daltrey"
-      actor.current_actor.should eq actor
+      expect(actor.current_actor).to eq actor
     end
 
     it "raises NotActorError if called outside an actor" do
@@ -509,39 +509,39 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
     it "links to other actors" do
       @kevin.link @charlie
-      @kevin.monitoring?(@charlie).should be_true
-      @kevin.linked_to?(@charlie).should  be_true
-      @charlie.monitoring?(@kevin).should be_true
-      @charlie.linked_to?(@kevin).should  be_true
+      expect(@kevin.monitoring?(@charlie)).to be_truthy
+      expect(@kevin.linked_to?(@charlie)).to  be_truthy
+      expect(@charlie.monitoring?(@kevin)).to be_truthy
+      expect(@charlie.linked_to?(@kevin)).to  be_truthy
     end
 
     it "unlinks from other actors" do
       @kevin.link @charlie
       @kevin.unlink @charlie
 
-      @kevin.monitoring?(@charlie).should be_false
-      @kevin.linked_to?(@charlie).should  be_false
-      @charlie.monitoring?(@kevin).should be_false
-      @charlie.linked_to?(@kevin).should  be_false
+      expect(@kevin.monitoring?(@charlie)).to be_falsey
+      expect(@kevin.linked_to?(@charlie)).to  be_falsey
+      expect(@charlie.monitoring?(@kevin)).to be_falsey
+      expect(@charlie.linked_to?(@kevin)).to  be_falsey
     end
 
     it "monitors other actors unidirectionally" do
       @kevin.monitor @charlie
 
-      @kevin.monitoring?(@charlie).should be_true
-      @kevin.linked_to?(@charlie).should  be_false
-      @charlie.monitoring?(@kevin).should be_false
-      @charlie.linked_to?(@kevin).should  be_false
+      expect(@kevin.monitoring?(@charlie)).to be_truthy
+      expect(@kevin.linked_to?(@charlie)).to  be_falsey
+      expect(@charlie.monitoring?(@kevin)).to be_falsey
+      expect(@charlie.linked_to?(@kevin)).to  be_falsey
     end
 
     it "unmonitors other actors" do
       @kevin.monitor @charlie
       @kevin.unmonitor @charlie
 
-      @kevin.monitoring?(@charlie).should be_false
-      @kevin.linked_to?(@charlie).should  be_false
-      @charlie.monitoring?(@kevin).should be_false
-      @charlie.linked_to?(@kevin).should  be_false
+      expect(@kevin.monitoring?(@charlie)).to be_falsey
+      expect(@kevin.linked_to?(@charlie)).to  be_falsey
+      expect(@charlie.monitoring?(@kevin)).to be_falsey
+      expect(@charlie.linked_to?(@kevin)).to  be_falsey
     end
 
     it "traps exit messages from other actors" do
@@ -553,7 +553,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end.to raise_exception(ExampleCrash)
 
       sleep 0.1 # hax to prevent a race between exit handling and the next call
-      chuck.should be_subordinate_lambasted
+      expect(chuck).to be_subordinate_lambasted
     end
 
     it "traps exit messages from other actors in subclasses" do
@@ -566,7 +566,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end.to raise_exception(ExampleCrash)
 
       sleep 0.1 # hax to prevent a race between exit handling and the next call
-      chuck.should be_subordinate_lambasted
+      expect(chuck).to be_subordinate_lambasted
     end
 
     it "unlinks from a dead linked actor" do
@@ -578,7 +578,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       end.to raise_exception(ExampleCrash)
 
       sleep 0.1 # hax to prevent a race between exit handling and the next call
-      chuck.links.count.should be(0)
+      expect(chuck.links.count).to be(0)
     end
   end
 
@@ -615,28 +615,28 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
     it "allows methods within the same object to signal each other" do
       obj = @signaler.new
-      obj.should_not be_signaled
+      expect(obj).not_to be_signaled
 
       obj.async.wait_for_signal
-      obj.should_not be_signaled
-      obj.should be_waiting
+      expect(obj).not_to be_signaled
+      expect(obj).to be_waiting
 
       obj.send_signal :foobar
-      obj.should be_signaled
-      obj.should_not be_waiting
+      expect(obj).to be_signaled
+      expect(obj).not_to be_waiting
     end
 
     it "sends values along with signals" do
       obj = @signaler.new
-      obj.should_not be_signaled
+      expect(obj).not_to be_signaled
 
       future = obj.future(:wait_for_signal)
 
-      obj.should be_waiting
-      obj.should_not be_signaled
+      expect(obj).to be_waiting
+      expect(obj).not_to be_signaled
 
-      obj.send_signal(:foobar).should be_true
-      future.value.should be(:foobar)
+      expect(obj.send_signal(:foobar)).to be_truthy
+      expect(future.value).to be(:foobar)
     end
   end
 
@@ -687,23 +687,23 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       subject.async.exclusive_with_block_log_task(:one)
       subject.async.log_task(:two)
       sleep Celluloid::TIMER_QUANTUM * 2
-      subject.tasks.should eq([:one, :two])
+      expect(subject.tasks).to eq([:one, :two])
     end
 
     it "executes methods in the proper order with a class-level annotation" do
       subject.async.exclusive_log_task :one
       subject.async.log_task :two
       sleep Celluloid::TIMER_QUANTUM * 2
-      subject.tasks.should eq([:one, :two])
+      expect(subject.tasks).to eq([:one, :two])
     end
 
     it "knows when it's in exclusive mode" do
-      subject.check_not_exclusive.should be_false
-      subject.check_exclusive.should be_true
+      expect(subject.check_not_exclusive).to be_falsey
+      expect(subject.check_exclusive).to be_truthy
     end
 
     it "remains in exclusive mode inside nested blocks" do
-      subject.nested_exclusive_example.should be_true
+      expect(subject.nested_exclusive_example).to be_truthy
     end
   end
 
@@ -736,7 +736,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       actor.async.eat_donuts
       actor.async.drink_coffee
       sleep Celluloid::TIMER_QUANTUM * 2
-      actor.tasks.should eq(['donuts', 'coffee'])
+      expect(actor.tasks).to eq(['donuts', 'coffee'])
     end
   end
 
@@ -758,20 +758,20 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     let(:message) { Object.new }
 
     it "allows unconditional receive" do
-      receiver.signal_myself(message).should eq(message)
+      expect(receiver.signal_myself(message)).to eq(message)
     end
 
     it "allows arbitrary selective receive" do
       received_obj = receiver.signal_myself(message) { |o| o == message }
-      received_obj.should eq(message)
+      expect(received_obj).to eq(message)
     end
 
     it "times out after the given interval", :pending => ENV['CI'] do
       interval = 0.1
       started_at = Time.now
 
-      receiver.receive(interval) { false }.should be_nil
-      (Time.now - started_at).should be_within(Celluloid::TIMER_QUANTUM).of interval
+      expect(receiver.receive(interval) { false }).to be_nil
+      expect(Time.now - started_at).to be_within(Celluloid::TIMER_QUANTUM).of interval
     end
   end
 
@@ -818,10 +818,10 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
 
       future = actor.future(:do_sleep, interval)
       sleep(interval / 2) # wonky! :/
-      actor.should be_sleeping
+      expect(actor).to be_sleeping
 
       future.value
-      (Time.now - started_at).should be_within(Celluloid::TIMER_QUANTUM).of interval
+      expect(Time.now - started_at).to be_within(Celluloid::TIMER_QUANTUM).of interval
     end
 
     it "schedules timers which fire in the future" do
@@ -830,10 +830,10 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       interval = Celluloid::TIMER_QUANTUM * 10
 
       actor.fire_after(interval)
-      actor.should_not be_fired
+      expect(actor).not_to be_fired
 
       sleep(interval + Celluloid::TIMER_QUANTUM) # wonky! #/
-      actor.should be_fired
+      expect(actor).to be_fired
     end
 
     it "schedules recurring timers which fire in the future" do
@@ -842,13 +842,13 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       interval = Celluloid::TIMER_QUANTUM * 10
 
       actor.fire_every(interval)
-      actor.fired.should be_zero
+      expect(actor.fired).to be_zero
 
       sleep(interval + Celluloid::TIMER_QUANTUM) # wonky! #/
-      actor.fired.should be 1
+      expect(actor.fired).to be 1
 
       2.times { sleep(interval + Celluloid::TIMER_QUANTUM) } # wonky! #/
-      actor.fired.should be 3
+      expect(actor.fired).to be 3
     end
 
     it "cancels timers before they fire" do
@@ -857,11 +857,11 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       interval = Celluloid::TIMER_QUANTUM * 10
 
       timer = actor.fire_after(interval)
-      actor.should_not be_fired
+      expect(actor).not_to be_fired
       timer.cancel
 
       sleep(interval + Celluloid::TIMER_QUANTUM) # wonky! #/
-      actor.should_not be_fired
+      expect(actor).not_to be_fired
     end
 
     it "allows delays from outside the actor" do
@@ -873,10 +873,10 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       actor.after(interval) do
         fired = true
       end
-      fired.should be_false
+      expect(fired).to be_falsey
 
       sleep(interval + Celluloid::TIMER_QUANTUM) # wonky! #/
-      fired.should be_true
+      expect(fired).to be_truthy
     end
   end
 
@@ -913,21 +913,21 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       actor = @klass.new
 
       tasks = actor.tasks
-      tasks.size.should be 1
+      expect(tasks.size).to be 1
 
       actor.future(:blocking_call)
       sleep 0.1 # hax! waiting for ^^^ call to actually start
 
       tasks = actor.tasks
-      tasks.size.should be 2
+      expect(tasks.size).to be 2
 
       blocking_task = tasks.find { |t| t.status != :running }
-      blocking_task.should be_a task_klass
-      blocking_task.status.should be :callwait
+      expect(blocking_task).to be_a task_klass
+      expect(blocking_task.status).to be :callwait
 
       actor.blocker.unblock
       sleep 0.1 # hax again :(
-      actor.tasks.size.should be 1
+      expect(actor.tasks.size).to be 1
     end
   end
 
@@ -943,12 +943,12 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "uses user-specified mailboxes" do
-      subject.new.mailbox.should be_a ExampleMailbox
+      expect(subject.new.mailbox).to be_a ExampleMailbox
     end
 
     it "retains custom mailboxes when subclassed" do
       subclass = Class.new(subject)
-      subclass.new.mailbox.should be_a ExampleMailbox
+      expect(subclass.new.mailbox).to be_a ExampleMailbox
     end
   end
 
@@ -962,7 +962,7 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "configures the mailbox limit" do
-      subject.new.mailbox.max_size.should == 100
+      expect(subject.new.mailbox.max_size).to eq(100)
     end
   end
 
@@ -982,12 +982,12 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "uses user-specified proxy" do
-      subject.new.should be_subclass_proxy
+      expect{subject.new.subclass_proxy?}.to_not raise_error
     end
 
     it "retains custom proxy when subclassed" do
       subclass = Class.new(subject)
-      subclass.new.should be_subclass_proxy
+      expect(subclass.new.subclass_proxy?).to be(true)
     end
   end
 
@@ -1002,12 +1002,12 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
     end
 
     it "overrides the task class" do
-      subject.new.tasks.first.should be_a ExampleTask
+      expect(subject.new.tasks.first).to be_a ExampleTask
     end
 
     it "retains custom task classes when subclassed" do
       subclass = Class.new(subject)
-      subclass.new.tasks.first.should be_a ExampleTask
+      expect(subclass.new.tasks.first).to be_a ExampleTask
     end
   end
 
@@ -1038,13 +1038,13 @@ shared_examples "Celluloid::Actor examples" do |included_module, task_klass|
       a1 = actor_class.new
       a2 = actor_class.new
 
-      a1.ask_name_with_timeout(a2, 0.6).should == :foo
+      expect(a1.ask_name_with_timeout(a2, 0.6)).to eq(:foo)
     end
   end
 
   context "raw message sends" do
     it "logs on unhandled messages" do
-      Celluloid.logger.should_receive(:debug).with("Discarded message (unhandled): first")
+      expect(Celluloid.logger).to receive(:debug).with("Discarded message (unhandled): first")
 
       actor = actor_class.new "Irma Gladden"
       actor.mailbox << :first
diff --git a/lib/celluloid/rspec/mailbox_examples.rb b/lib/celluloid/rspec/mailbox_examples.rb
index d8fd193..c74585c 100644
--- a/lib/celluloid/rspec/mailbox_examples.rb
+++ b/lib/celluloid/rspec/mailbox_examples.rb
@@ -1,6 +1,6 @@
 shared_context "a Celluloid Mailbox" do
   after do
-    Celluloid.logger.stub(:debug)
+    allow(Celluloid.logger).to receive(:debug)
     subject.shutdown if subject.alive?
   end
 
@@ -8,7 +8,7 @@ shared_context "a Celluloid Mailbox" do
     message = :ohai
 
     subject << message
-    subject.receive.should == message
+    expect(subject.receive).to eq(message)
   end
 
   it "prioritizes system events over other messages" do
@@ -16,7 +16,7 @@ shared_context "a Celluloid Mailbox" do
     subject << :dummy2
 
     subject << Celluloid::SystemEvent.new
-    subject.receive.should be_a(Celluloid::SystemEvent)
+    expect(subject.receive).to be_a(Celluloid::SystemEvent)
   end
 
   it "selectively receives messages with a block" do
@@ -30,9 +30,9 @@ shared_context "a Celluloid Mailbox" do
     subject << foo
     subject << bar
 
-    subject.receive { |msg| msg.is_a? Foo }.should eq(foo)
-    subject.receive { |msg| msg.is_a? Bar }.should eq(bar)
-    subject.receive.should eq(baz)
+    expect(subject.receive { |msg| msg.is_a? Foo }).to eq(foo)
+    expect(subject.receive { |msg| msg.is_a? Bar }).to eq(bar)
+    expect(subject.receive).to eq(baz)
   end
 
   it "waits for a given timeout interval" do
@@ -43,15 +43,15 @@ shared_context "a Celluloid Mailbox" do
       subject.receive(interval) { false }
     end.to raise_exception(Celluloid::TimeoutError)
 
-    (Time.now - started_at).should be_within(Celluloid::TIMER_QUANTUM).of interval
+    expect(Time.now - started_at).to be_within(Celluloid::TIMER_QUANTUM).of interval
   end
 
   it "has a size" do
-    subject.should respond_to(:size)
-    subject.size.should be_zero
+    expect(subject).to respond_to(:size)
+    expect(subject.size).to be_zero
     subject << :foo
     subject << :foo
-    subject.should have(2).entries
+    expect(subject.entries.size).to eq(2)
   end
 
   it "discards messages received when when full" do
@@ -59,11 +59,11 @@ shared_context "a Celluloid Mailbox" do
     subject << :first
     subject << :second
     subject << :third
-    subject.to_a.should =~ [:first, :second]
+    expect(subject.to_a).to match_array([:first, :second])
   end
 
   it "logs discarded messages" do
-    Celluloid.logger.should_receive(:debug).with("Discarded message (mailbox is dead): third")
+    expect(Celluloid.logger).to receive(:debug).with("Discarded message (mailbox is dead): third")
 
     subject.max_size = 2
     subject << :first
@@ -72,9 +72,9 @@ shared_context "a Celluloid Mailbox" do
   end
 
   it "discard messages when dead" do
-    Celluloid.logger.should_receive(:debug).with("Discarded message (mailbox is dead): first")
-    Celluloid.logger.should_receive(:debug).with("Discarded message (mailbox is dead): second")
-    Celluloid.logger.should_receive(:debug).with("Discarded message (mailbox is dead): third")
+    expect(Celluloid.logger).to receive(:debug).with("Discarded message (mailbox is dead): first")
+    expect(Celluloid.logger).to receive(:debug).with("Discarded message (mailbox is dead): second")
+    expect(Celluloid.logger).to receive(:debug).with("Discarded message (mailbox is dead): third")
 
     subject << :first
     subject << :second
diff --git a/lib/celluloid/rspec/task_examples.rb b/lib/celluloid/rspec/task_examples.rb
index 23dbbd7..fb9b3a8 100644
--- a/lib/celluloid/rspec/task_examples.rb
+++ b/lib/celluloid/rspec/task_examples.rb
@@ -27,15 +27,15 @@ shared_context "a Celluloid Task" do |task_class|
   end
 
   it "begins with status :new" do
-    subject.status.should be :new
+    expect(subject.status).to be :new
   end
 
   it "resumes" do
-    subject.should be_running
+    expect(subject).to be_running
     subject.resume
-    subject.status.should eq(suspend_state)
+    expect(subject.status).to eq(suspend_state)
     subject.resume
-    subject.should_not be_running
+    expect(subject).not_to be_running
   end
 
   it "raises exceptions outside" do
diff --git a/spec/celluloid/actor_system_spec.rb b/spec/celluloid/actor_system_spec.rb
index fffc559..e79c5b7 100644
--- a/spec/celluloid/actor_system_spec.rb
+++ b/spec/celluloid/actor_system_spec.rb
@@ -7,41 +7,41 @@ describe Celluloid::ActorSystem do
 
   it "supports non-global ActorSystem" do
     subject.within do
-      Celluloid.actor_system.should == subject
+      expect(Celluloid.actor_system).to eq(subject)
     end
   end
 
   it "starts default actors" do
     subject.start
 
-    subject.registered.should == [:notifications_fanout, :default_incident_reporter]
+    expect(subject.registered).to eq([:notifications_fanout, :default_incident_reporter])
   end
 
   it "support getting threads" do
     queue = Queue.new
     thread = subject.get_thread do
-      Celluloid.actor_system.should == subject
+      expect(Celluloid.actor_system).to eq(subject)
       queue << nil
     end
     queue.pop
   end
 
   it "allows a stack dump" do
-    subject.stack_dump.should be_a(Celluloid::StackDump)
+    expect(subject.stack_dump).to be_a(Celluloid::StackDump)
   end
 
   it "returns named actors" do
-    subject.registered.should be_empty
+    expect(subject.registered).to be_empty
 
     subject.within do
       TestActor.supervise_as :test
     end
 
-    subject.registered.should == [:test]
+    expect(subject.registered).to eq([:test])
   end
 
   it "returns running actors" do
-    subject.running.should be_empty
+    expect(subject.running).to be_empty
 
     first = subject.within do
       TestActor.new
@@ -51,19 +51,19 @@ describe Celluloid::ActorSystem do
       TestActor.new
     end
 
-    subject.running.should == [first, second]
+    expect(subject.running).to eq([first, second])
   end
 
   it "shuts down" do
     subject.shutdown
 
-    lambda { subject.get_thread }.
-      should raise_error("Thread pool is not running")
+    expect { subject.get_thread }.
+      to raise_error("Thread pool is not running")
   end
 
   it "warns nicely when no actor system is started" do
-    lambda { TestActor.new }.
-      should raise_error("Celluloid is not yet started; use Celluloid.boot")
+    expect { TestActor.new }.
+      to raise_error("Celluloid is not yet started; use Celluloid.boot")
   end
 
 end
diff --git a/spec/celluloid/block_spec.rb b/spec/celluloid/block_spec.rb
index fc6ac85..73ad200 100644
--- a/spec/celluloid/block_spec.rb
+++ b/spec/celluloid/block_spec.rb
@@ -49,6 +49,6 @@ describe "Blocks", actor_system: :global do
       "somevalue",
     ]
 
-    $data.should eq(expected)
+    expect($data).to eq(expected)
   end
 end
diff --git a/spec/celluloid/calls_spec.rb b/spec/celluloid/calls_spec.rb
index c7b8e14..ae4025d 100644
--- a/spec/celluloid/calls_spec.rb
+++ b/spec/celluloid/calls_spec.rb
@@ -22,7 +22,7 @@ describe Celluloid::SyncCall, actor_system: :global do
       actor.the_method_that_wasnt_there
     end.to raise_exception(NoMethodError)
 
-    actor.should be_alive
+    expect(actor).to be_alive
   end
 
   it "aborts with ArgumentError when a method is called with too many arguments" do
@@ -30,13 +30,13 @@ describe Celluloid::SyncCall, actor_system: :global do
       actor.actual_method("with too many arguments")
     end.to raise_exception(ArgumentError)
 
-    actor.should be_alive
+    expect(actor).to be_alive
   end
 
   it "preserves call chains across synchronous calls" do
     actor2 = CallExampleActor.new(actor)
 
     uuid, next_actor_uuid = actor2.chained_call_ids
-    uuid.should eq next_actor_uuid
+    expect(uuid).to eq next_actor_uuid
   end
 end
diff --git a/spec/celluloid/condition_spec.rb b/spec/celluloid/condition_spec.rb
index 12ef65e..111fbf5 100644
--- a/spec/celluloid/condition_spec.rb
+++ b/spec/celluloid/condition_spec.rb
@@ -37,40 +37,40 @@ describe Celluloid::Condition, actor_system: :global do
 
   it "sends signals" do
     3.times { actor.async.wait_for_condition }
-    actor.signaled_times.should be_zero
+    expect(actor.signaled_times).to be_zero
 
     actor.condition.signal
-    actor.signaled_times.should be(1)
+    expect(actor.signaled_times).to be(1)
   end
 
   it "broadcasts signals" do
     3.times { actor.async.wait_for_condition }
-    actor.signaled_times.should be_zero
+    expect(actor.signaled_times).to be_zero
 
     actor.condition.broadcast
-    actor.signaled_times.should be(3)
+    expect(actor.signaled_times).to be(3)
   end
 
   it "sends values along with signals" do
     future = actor.future(:wait_for_condition)
     actor.condition.signal(:example_value)
-    future.value.should be(:example_value)
+    expect(future.value).to be(:example_value)
   end
 
   it "supports waiting outside actors" do
     condition = Celluloid::Condition.new
     actor.async.signal_condition condition, :value
-    condition.wait.should eq(:value)
+    expect(condition.wait).to eq(:value)
   end
 
   it "times out inside normal Threads" do
     condition = Celluloid::Condition.new
-    lambda { condition.wait(1) }.
-      should raise_error(Celluloid::ConditionError)
+    expect { condition.wait(1) }.
+      to raise_error(Celluloid::ConditionError)
   end
 
   it "times out inside Tasks" do
-    lambda { actor.wait_for_condition(1) }.
-      should raise_error(Celluloid::ConditionError)
+    expect { actor.wait_for_condition(1) }.
+      to raise_error(Celluloid::ConditionError)
   end
 end
diff --git a/spec/celluloid/cpu_counter_spec.rb b/spec/celluloid/cpu_counter_spec.rb
index 4bb934e..4753194 100644
--- a/spec/celluloid/cpu_counter_spec.rb
+++ b/spec/celluloid/cpu_counter_spec.rb
@@ -1,22 +1,25 @@
 require 'spec_helper'
 
 describe Celluloid::CPUCounter do
-  describe :cores do
+  describe "#cores" do
     subject { described_class.cores }
 
     let(:num_cores) { 1024 }
 
     before do
-      described_class.stub(:`) { fail 'backtick stub called' }
-      ::IO.stub(:open).and_raise('IO.open stub called!')
-      described_class.instance_variable_set('@cores', nil)
+      allow(described_class).to receive(:`) { fail 'backtick stub called' }
+      allow(::IO).to receive(:open).and_raise('IO.open stub called!')
+      described_class.instance_variable_set(:@cores, nil)
     end
 
-    after { ENV['NUMBER_OF_PROCESSORS'] = nil }
+    after do
+      ENV['NUMBER_OF_PROCESSORS'] = nil
+      described_class.instance_variable_set(:@cores, nil)
+    end
 
     context 'from valid env value' do
       before { ENV['NUMBER_OF_PROCESSORS'] = num_cores.to_s }
-      it { should eq num_cores }
+      it { is_expected.to eq num_cores }
     end
 
     context 'from invalid env value' do
@@ -29,15 +32,15 @@ describe Celluloid::CPUCounter do
 
       context 'when /sys/devices/system/cpu/present exists' do
         before do
-          ::IO.should_receive(:read).with('/sys/devices/system/cpu/present')
+          expect(::IO).to receive(:read).with('/sys/devices/system/cpu/present')
             .and_return("dunno-whatever-#{num_cores - 1}")
         end
-        it { should eq num_cores }
+        it { is_expected.to eq num_cores }
       end
 
       context 'when /sys/devices/system/cpu/present does NOT exist' do
         before do
-          ::IO.should_receive(:read).with('/sys/devices/system/cpu/present')
+          expect(::IO).to receive(:read).with('/sys/devices/system/cpu/present')
             .and_raise(Errno::ENOENT)
         end
 
@@ -45,35 +48,35 @@ describe Celluloid::CPUCounter do
           before do
             cpu_entries = (1..num_cores).map { |n| "cpu#{n}" }
             cpu_entries << 'non-cpu-entry-to-ignore'
-            Dir.should_receive(:[]).with('/sys/devices/system/cpu/cpu*')
+            expect(Dir).to receive(:[]).with('/sys/devices/system/cpu/cpu*')
               .and_return(cpu_entries)
           end
-          it { should eq num_cores }
+          it { is_expected.to eq num_cores }
         end
 
         context 'when /sys/devices/system/cpu/cpu* files DO NOT exist' do
           before do
-            Dir.should_receive(:[]).with('/sys/devices/system/cpu/cpu*')
+            expect(Dir).to receive(:[]).with('/sys/devices/system/cpu/cpu*')
               .and_return([])
           end
 
           context 'when sysctl blows up' do
-            before { described_class.stub(:`).and_raise(Errno::EINTR) }
+            before { allow(described_class).to receive(:`).and_raise(Errno::EINTR) }
             specify { expect { subject }.to raise_error }
           end
 
           context 'when sysctl fails' do
-            before { described_class.stub(:`).and_return(`false`) }
-            it { should be nil }
+            before { allow(described_class).to receive(:`).and_return(`false`) }
+            it { is_expected.to be nil }
           end
 
           context 'when sysctl succeeds' do
             before do
-              described_class.should_receive(:`).with('sysctl -n hw.ncpu')
+              expect(described_class).to receive(:`).with('sysctl -n hw.ncpu')
                 .and_return(num_cores.to_s)
               `true`
             end
-            it { should eq num_cores }
+            it { is_expected.to eq num_cores }
           end
         end
       end
diff --git a/spec/celluloid/fsm_spec.rb b/spec/celluloid/fsm_spec.rb
index ea9cc81..29109d5 100644
--- a/spec/celluloid/fsm_spec.rb
+++ b/spec/celluloid/fsm_spec.rb
@@ -34,23 +34,23 @@ describe Celluloid::FSM, actor_system: :global do
   subject { TestMachine.new }
 
   it "starts in the default state" do
-    subject.state.should eq(TestMachine.default_state)
+    expect(subject.state).to eq(TestMachine.default_state)
   end
 
   it "transitions between states" do
-    subject.state.should_not be :done
+    expect(subject.state).not_to be :done
     subject.transition :done
-    subject.state.should be :done
+    expect(subject.state).to be :done
   end
 
   it "fires callbacks for states" do
-    subject.should_not be_fired
+    expect(subject).not_to be_fired
     subject.transition :callbacked
-    subject.should be_fired
+    expect(subject).to be_fired
   end
 
   it "allows custom default states" do
-    CustomDefaultMachine.new.state.should be :foobar
+    expect(CustomDefaultMachine.new.state).to be :foobar
   end
 
   it "supports constraints on valid state transitions" do
@@ -65,10 +65,10 @@ describe Celluloid::FSM, actor_system: :global do
     subject.transition :another
     subject.transition :done, :delay => interval
 
-    subject.state.should be :another
+    expect(subject.state).to be :another
     sleep interval + Celluloid::TIMER_QUANTUM
 
-    subject.state.should be :done
+    expect(subject.state).to be :done
   end
 
   it "cancels delayed state transitions if another transition is made" do
@@ -78,11 +78,11 @@ describe Celluloid::FSM, actor_system: :global do
     subject.transition :another
     subject.transition :done, :delay => interval
 
-    subject.state.should be :another
+    expect(subject.state).to be :another
     subject.transition :pre_done
     sleep interval + Celluloid::TIMER_QUANTUM
 
-    subject.state.should be :pre_done
+    expect(subject.state).to be :pre_done
   end
 
   context "actor is not set" do
@@ -100,7 +100,7 @@ describe Celluloid::FSM, actor_system: :global do
     end
 
     it "should not call transition! if the state is :default" do
-      subject.should_not_receive :transition!
+      expect(subject).not_to receive :transition!
       subject.transition :default
     end
   end
diff --git a/spec/celluloid/future_spec.rb b/spec/celluloid/future_spec.rb
index 9201b80..b939902 100644
--- a/spec/celluloid/future_spec.rb
+++ b/spec/celluloid/future_spec.rb
@@ -3,12 +3,12 @@ require 'spec_helper'
 describe Celluloid::Future, actor_system: :global do
   it "creates future objects that can be retrieved later" do
     future = Celluloid::Future.new { 40 + 2 }
-    future.value.should == 42
+    expect(future.value).to eq(42)
   end
 
   it "passes arguments to future blocks" do
     future = Celluloid::Future.new(40) { |n| n + 2 }
-    future.value.should == 42
+    expect(future.value).to eq(42)
   end
 
   it "reraises exceptions that occur when the value is retrieved" do
@@ -20,9 +20,9 @@ describe Celluloid::Future, actor_system: :global do
 
   it "knows if it's got a value yet" do
     future = Celluloid::Future.new { sleep Celluloid::TIMER_QUANTUM * 5 }
-    future.should_not be_ready
+    expect(future).not_to be_ready
     sleep Celluloid::TIMER_QUANTUM * 6
-    future.should be_ready
+    expect(future).to be_ready
   end
 
   it "raises TimeoutError when the future times out" do
diff --git a/spec/celluloid/internal_pool_spec.rb b/spec/celluloid/internal_pool_spec.rb
index f372fcb..9915234 100644
--- a/spec/celluloid/internal_pool_spec.rb
+++ b/spec/celluloid/internal_pool_spec.rb
@@ -2,51 +2,51 @@ require 'spec_helper'
 
 describe Celluloid::InternalPool do
   it "gets threads from the pool" do
-    subject.get { sleep 1 }.should be_a Thread
+    expect(subject.get { sleep 1 }).to be_a Thread
   end
 
   it "puts threads back into the pool" do
-    subject.idle_size.should be_zero
-    subject.busy_size.should be_zero
+    expect(subject.idle_size).to be_zero
+    expect(subject.busy_size).to be_zero
 
     queue = Queue.new
     subject.get { queue.pop }
 
-    subject.idle_size.should be_zero
-    subject.busy_size.should eq 1
+    expect(subject.idle_size).to be_zero
+    expect(subject.busy_size).to eq 1
 
     queue << nil
     sleep 0.01 # hax
 
-    subject.idle_size.should eq 1
-    subject.busy_size.should eq 0
+    expect(subject.idle_size).to eq 1
+    expect(subject.busy_size).to eq 0
   end
 
   it "cleans thread locals from old threads" do
     thread = subject.get { Thread.current[:foo] = :bar }
 
     sleep 0.01 #hax
-    thread[:foo].should be_nil
+    expect(thread[:foo]).to be_nil
   end
 
   it "doesn't fail if a third-party thread is spawned" do
-    subject.idle_size.should be_zero
-    subject.busy_size.should be_zero
+    expect(subject.idle_size).to be_zero
+    expect(subject.busy_size).to be_zero
 
-    subject.get { ::Thread.new { sleep 0.5 } }.should be_a(Celluloid::Thread)
+    expect(subject.get { ::Thread.new { sleep 0.5 } }).to be_a(Celluloid::Thread)
 
     sleep 0.01 # hax
 
-    subject.idle_size.should eq 1
-    subject.busy_size.should eq 0
+    expect(subject.idle_size).to eq 1
+    expect(subject.busy_size).to eq 0
   end
 
   it "doesn't leak dead threads" do
     subject.max_idle = 0 # Instruct the pool to immediately shut down the thread.
-    subject.get { true }.should be_a(Celluloid::Thread)
+    expect(subject.get { true }).to be_a(Celluloid::Thread)
 
     sleep 0.01 # hax
 
-    subject.to_a.should have(0).items
+    expect(subject.to_a.size).to eq(0)
   end
 end
diff --git a/spec/celluloid/links_spec.rb b/spec/celluloid/links_spec.rb
index a67b828..23179ea 100644
--- a/spec/celluloid/links_spec.rb
+++ b/spec/celluloid/links_spec.rb
@@ -21,25 +21,25 @@ describe Celluloid::Links do
   end
 
   it 'is Enumerable' do
-    subject.should be_an(Enumerable)
+    expect(subject).to be_an(Enumerable)
   end
 
   it 'adds actors by their mailbox address' do
-    subject.include?(first_actor).should be_false
+    expect(subject.include?(first_actor)).to be_falsey
     subject << first_actor
-    subject.include?(first_actor).should be_true
+    expect(subject.include?(first_actor)).to be_truthy
   end
 
   it 'removes actors by their mailbox address' do
     subject << first_actor
-    subject.include?(first_actor).should be_true
+    expect(subject.include?(first_actor)).to be_truthy
     subject.delete first_actor
-    subject.include?(first_actor).should be_false
+    expect(subject.include?(first_actor)).to be_falsey
   end
 
   it 'iterates over all actors' do
     subject << first_actor
     subject << second_actor
-    subject.inject([]) { |all, a| all << a }.should == [first_actor, second_actor]
+    expect(subject.inject([]) { |all, a| all << a }).to eq([first_actor, second_actor])
   end
 end
diff --git a/spec/celluloid/logging/ring_buffer_spec.rb b/spec/celluloid/logging/ring_buffer_spec.rb
index d9efb15..c0b96ed 100644
--- a/spec/celluloid/logging/ring_buffer_spec.rb
+++ b/spec/celluloid/logging/ring_buffer_spec.rb
@@ -3,33 +3,33 @@ require 'spec_helper'
 describe Celluloid::RingBuffer do
   subject { Celluloid::RingBuffer.new(2) }
 
-  it { should be_empty }
-  it { should_not be_full }
+  it { is_expected.to be_empty }
+  it { is_expected.not_to be_full }
 
   it 'should push and shift' do
     subject.push('foo')
     subject.push('foo2')
-    subject.shift.should eq('foo')
-    subject.shift.should eq('foo2')
+    expect(subject.shift).to eq('foo')
+    expect(subject.shift).to eq('foo2')
   end
 
   it 'should push past the end' do
     subject.push('foo')
     subject.push('foo2')
     subject.push('foo3')
-    subject.should be_full
+    expect(subject).to be_full
   end
 
   it 'should shift the most recent' do
     (1..5).each { |i| subject.push(i) }
-    subject.shift.should be 4
-    subject.shift.should be 5
-    subject.shift.should be_nil
+    expect(subject.shift).to be 4
+    expect(subject.shift).to be 5
+    expect(subject.shift).to be_nil
   end
 
   it 'should return nil when shifting empty' do
-    subject.should be_empty
-    subject.shift.should be_nil
+    expect(subject).to be_empty
+    expect(subject.shift).to be_nil
   end
 
   it 'should be thread-safe' do
diff --git a/spec/celluloid/notifications_spec.rb b/spec/celluloid/notifications_spec.rb
index df581a2..ee32606 100644
--- a/spec/celluloid/notifications_spec.rb
+++ b/spec/celluloid/notifications_spec.rb
@@ -34,8 +34,8 @@ describe Celluloid::Notifications, actor_system: :global do
     president = President.new
 
     president.die
-    marilyn.mourning.should eq("Mr. President")
-    jackie.mourning.should_not eq("Mr. President")
+    expect(marilyn.mourning).to eq("Mr. President")
+    expect(jackie.mourning).not_to eq("Mr. President")
   end
 
   it 'allows multiple subscriptions from the same actor' do
@@ -47,7 +47,7 @@ describe Celluloid::Notifications, actor_system: :global do
     president = President.new
 
     president.die
-    marilyn.mourning_count.should be(2)
+    expect(marilyn.mourning_count).to be(2)
   end
 
 
@@ -61,8 +61,8 @@ describe Celluloid::Notifications, actor_system: :global do
     president = President.new
 
     president.die
-    marilyn.mourning.should eq("Mr. President")
-    jackie.mourning.should eq("Mr. President")
+    expect(marilyn.mourning).to eq("Mr. President")
+    expect(jackie.mourning).to eq("Mr. President")
   end
 
   it 'publishes even if there are no subscribers' do
@@ -77,7 +77,7 @@ describe Celluloid::Notifications, actor_system: :global do
 
     president = President.new
     president.die
-    marilyn.mourning.should eq("Mr. President")
+    expect(marilyn.mourning).to eq("Mr. President")
   end
 
   it 'allows unsubscribing' do
@@ -88,7 +88,7 @@ describe Celluloid::Notifications, actor_system: :global do
 
     president = President.new
     president.die
-    marilyn.mourning.should be_nil
+    expect(marilyn.mourning).to be_nil
   end
 
   it 'prunes dead subscriptions' do
@@ -102,7 +102,7 @@ describe Celluloid::Notifications, actor_system: :global do
     marilyn.terminate
     after_listeners = Celluloid::Notifications.notifier.listeners_for("death").size
 
-    after_listeners.should == listeners - 1
+    expect(after_listeners).to eq(listeners - 1)
   end
 
   it 'prunes multiple subscriptions from a dead actor' do
@@ -115,6 +115,6 @@ describe Celluloid::Notifications, actor_system: :global do
     marilyn.terminate
     after_listeners = Celluloid::Notifications.notifier.listeners_for("death").size
 
-    after_listeners.should eq(listeners - 2)
+    expect(after_listeners).to eq(listeners - 2)
   end
 end
diff --git a/spec/celluloid/pool_spec.rb b/spec/celluloid/pool_spec.rb
index 713382d..ba4a393 100644
--- a/spec/celluloid/pool_spec.rb
+++ b/spec/celluloid/pool_spec.rb
@@ -34,18 +34,18 @@ describe "Celluloid.pool", actor_system: :global do
   subject { MyWorker.pool }
 
   it "processes work units synchronously" do
-    subject.process.should be :done
+    expect(subject.process).to be :done
   end
 
   it "processes work units asynchronously" do
     queue = Queue.new
     subject.async.process(queue)
-    queue.pop.should be :done
+    expect(queue.pop).to be :done
   end
 
   it "handles crashes" do
     expect { subject.crash }.to raise_error(ExampleError)
-    subject.process.should be :done
+    expect(subject.process).to be :done
   end
 
   it "uses a fixed-sized number of threads" do
@@ -55,7 +55,7 @@ describe "Celluloid.pool", actor_system: :global do
     100.times.map { subject.future(:process) }.map(&:value)
 
     new_actors = Celluloid::Actor.all - actors
-    new_actors.should eq []
+    expect(new_actors).to eq []
   end
 
   it "terminates" do
@@ -72,21 +72,21 @@ describe "Celluloid.pool", actor_system: :global do
   context "#size=" do
     subject { MyWorker.pool size: 4 }
 
-    it "should adjust the pool size up", pending: 'flaky' do
+    it "should adjust the pool size up", flaky: true do
       expect(test_concurrency_of(subject)).to eq(4)
 
       subject.size = 6
-      subject.size.should == 6
+      expect(subject.size).to eq(6)
 
-      test_concurrency_of(subject).should == 6
+      expect(test_concurrency_of(subject)).to eq(6)
     end
 
-    it "should adjust the pool size down" do
-      test_concurrency_of(subject).should == 4
+    it "should adjust the pool size down", flaky: true do
+      expect(test_concurrency_of(subject)).to eq(4)
 
       subject.size = 2
-      subject.size.should == 2
-      test_concurrency_of(subject).should == 2
+      expect(subject.size).to eq(2)
+      expect(test_concurrency_of(subject)).to eq(2)
     end
   end
 end
diff --git a/spec/celluloid/probe_spec.rb b/spec/celluloid/probe_spec.rb
index a6f9c8e..59eb9b2 100644
--- a/spec/celluloid/probe_spec.rb
+++ b/spec/celluloid/probe_spec.rb
@@ -64,11 +64,11 @@ describe "Probe", actor_system: :global do
           end
         end
       end
-      received_named_events.all?{|_, v| v != nil }.should == true
+      expect(received_named_events.all?{|_, v| v != nil }).to eq(true)
       # now check we got the create events for every actors
       received_named_events.each do |_, mailbox_address|
         found = create_events.detect{|_, aa| aa.mailbox.address == mailbox_address }
-        found.should_not == nil
+        expect(found).not_to eq(nil)
       end
     end
   end
@@ -81,7 +81,7 @@ describe "Probe", actor_system: :global do
       event = Timeout.timeout(5) do
         client.wait_event('celluloid.events.actor_created', a)
       end
-      event.should_not == nil
+      expect(event).not_to eq(nil)
     end
 
     it 'should send a notification when an actor is named' do
@@ -92,7 +92,7 @@ describe "Probe", actor_system: :global do
       event = Timeout.timeout(5) do
         client.wait_event('celluloid.events.actor_named', a)
       end
-      event.should_not == nil
+      expect(event).not_to eq(nil)
     end
 
     it 'should send a notification when actor dies' do
@@ -103,7 +103,7 @@ describe "Probe", actor_system: :global do
       event = Timeout.timeout(5) do
         client.wait_event('celluloid.events.actor_died', a)
       end
-      event.should_not == nil
+      expect(event).not_to eq(nil)
     end
 
     it 'should send a notification when actors are linked' do
@@ -115,7 +115,7 @@ describe "Probe", actor_system: :global do
       event = Timeout.timeout(5) do
         client.wait_event('celluloid.events.actors_linked', a, b)
       end
-      event.should_not == nil
+      expect(event).not_to eq(nil)
     end
   end
 end
diff --git a/spec/celluloid/properties_spec.rb b/spec/celluloid/properties_spec.rb
index c31998b..5b14016 100644
--- a/spec/celluloid/properties_spec.rb
+++ b/spec/celluloid/properties_spec.rb
@@ -20,23 +20,23 @@ describe Celluloid::Properties do
   end
 
   it "adds properties to classes" do
-    example_class.baz.should eq default_value
+    expect(example_class.baz).to eq default_value
     example_class.baz changed_value
-    example_class.baz.should eq changed_value
+    expect(example_class.baz).to eq changed_value
   end
 
   it "allows properties to be inherited" do
-    example_subclass.baz.should eq default_value
+    expect(example_subclass.baz).to eq default_value
     example_subclass.baz changed_value
-    example_subclass.baz.should eq changed_value
-    example_class.baz.should eq default_value
+    expect(example_subclass.baz).to eq changed_value
+    expect(example_class.baz).to eq default_value
   end
 
   it "allows properties to be deeply inherited" do
-    example_subclass_subclass.baz.should eq default_value
+    expect(example_subclass_subclass.baz).to eq default_value
     example_subclass_subclass.baz changed_value
-    example_subclass_subclass.baz.should eq changed_value
-    example_subclass.baz.should eq default_value
-    example_class.baz.should eq default_value
+    expect(example_subclass_subclass.baz).to eq changed_value
+    expect(example_subclass.baz).to eq default_value
+    expect(example_class.baz).to eq default_value
   end
 end
\ No newline at end of file
diff --git a/spec/celluloid/registry_spec.rb b/spec/celluloid/registry_spec.rb
index 2584590..bf30634 100644
--- a/spec/celluloid/registry_spec.rb
+++ b/spec/celluloid/registry_spec.rb
@@ -11,7 +11,7 @@ describe Celluloid::Registry, actor_system: :global do
 
   it "registers Actors" do
     Celluloid::Actor[:marilyn] = Marilyn.new
-    Celluloid::Actor[:marilyn].sing_for("Mr. President").should == "o/~ Happy birthday, Mr. President"
+    expect(Celluloid::Actor[:marilyn].sing_for("Mr. President")).to eq("o/~ Happy birthday, Mr. President")
   end
 
   it "refuses to register non-Actors" do
@@ -22,12 +22,12 @@ describe Celluloid::Registry, actor_system: :global do
 
   it "lists all registered actors" do
     Celluloid::Actor[:marilyn] = Marilyn.new
-    Celluloid::Actor.registered.should include :marilyn
+    expect(Celluloid::Actor.registered).to include :marilyn
   end
 
   it "knows its name once registered" do
     Celluloid::Actor[:marilyn] = Marilyn.new
-    Celluloid::Actor[:marilyn].registered_name.should == :marilyn
+    expect(Celluloid::Actor[:marilyn].registered_name).to eq(:marilyn)
   end
 
   describe :delete do
@@ -37,12 +37,12 @@ describe Celluloid::Registry, actor_system: :global do
 
     it "removes reference to actors' name from the registry" do
       Celluloid::Actor.delete(:marilyn)
-      Celluloid::Actor.registered.should_not include :marilyn
+      expect(Celluloid::Actor.registered).not_to include :marilyn
     end
 
     it "returns actor removed from the registry" do
       rval = Celluloid::Actor.delete(:marilyn)
-      rval.should be_kind_of(Marilyn)
+      expect(rval).to be_kind_of(Marilyn)
     end
   end
 
@@ -51,10 +51,10 @@ describe Celluloid::Registry, actor_system: :global do
       Celluloid::Actor[:marilyn] ||= Marilyn.new
       rval = Celluloid::Actor.clear_registry
       begin
-        rval.should be_kind_of(Hash)
-        rval.should have_key(:marilyn)
-        rval[:marilyn].wrapped_object.should be_instance_of(Marilyn)
-        Celluloid::Actor.registered.should be_empty
+        expect(rval).to be_kind_of(Hash)
+        expect(rval).to have_key(:marilyn)
+        expect(rval[:marilyn].wrapped_object).to be_instance_of(Marilyn)
+        expect(Celluloid::Actor.registered).to be_empty
       ensure
         # Repopulate the registry once we're done
         rval.each { |key, actor| Celluloid::Actor[key] = actor }
diff --git a/spec/celluloid/stack_dump_spec.rb b/spec/celluloid/stack_dump_spec.rb
index 9a39028..c150e65 100644
--- a/spec/celluloid/stack_dump_spec.rb
+++ b/spec/celluloid/stack_dump_spec.rb
@@ -28,36 +28,41 @@ describe Celluloid::StackDump do
       actor.async.blocking
     end
 
+    sleep 0.01 # to allow internal_pool to end up with 1 idle thread
+
     @active_thread = actor_system.get_thread do
       sleep
     end
     @active_thread.role = :other_thing
+
+    sleep 0.01 # to allow internal_pool to end up with 1 idle thread
+
     @idle_thread = actor_system.get_thread do
     end
 
-    sleep 0.01
+    sleep 0.01 # to allow internal_pool to end up with 1 idle thread
   end
 
   describe '#actors' do
     it 'should include all actors' do
-      subject.actors.size.should == actor_system.running.size
+      expect(subject.actors.size).to eq(actor_system.running.size)
     end
   end
 
   describe '#threads' do
-    it 'should include threads that are not actors', pending: 'flaky' do
+    it 'should include threads that are not actors', flaky: true do
       expect(subject.threads.size).to eq(3)
     end
 
-    it 'should include idle threads' do
-      subject.threads.map(&:thread_id).should include(@idle_thread.object_id)
+    it 'should include idle threads', flaky: true do
+      expect(subject.threads.map(&:thread_id)).to include(@idle_thread.object_id)
     end
 
-    it 'should include threads checked out of the pool for roles other than :actor' do
-      subject.threads.map(&:thread_id).should include(@active_thread.object_id)
+    it 'should include threads checked out of the pool for roles other than :actor', flaky: true do
+      expect(subject.threads.map(&:thread_id)).to include(@active_thread.object_id)
     end
 
-    it 'should have the correct roles', pending: 'flaky' do
+    it 'should have the correct roles', flaky: true do
       expect(subject.threads.map(&:role)).to include(nil, :other_thing, :task)
     end
   end
diff --git a/spec/celluloid/supervision_group_spec.rb b/spec/celluloid/supervision_group_spec.rb
index b8fb5e5..09242e8 100644
--- a/spec/celluloid/supervision_group_spec.rb
+++ b/spec/celluloid/supervision_group_spec.rb
@@ -17,7 +17,7 @@ describe Celluloid::SupervisionGroup, actor_system: :global do
     MyGroup.run!
     sleep 0.01 # startup time hax
 
-    Celluloid::Actor[:example].should be_running
+    expect(Celluloid::Actor[:example]).to be_running
   end
 
   it "accepts a private actor registry" do
@@ -25,13 +25,13 @@ describe Celluloid::SupervisionGroup, actor_system: :global do
     MyGroup.run!(my_registry)
     sleep 0.01
 
-    my_registry[:example].should be_running
+    expect(my_registry[:example]).to be_running
   end
 
   it "removes actors from the registry when terminating" do
     group = MyGroup.run!
     group.terminate
-    Celluloid::Actor[:example].should be_nil
+    expect(Celluloid::Actor[:example]).to be_nil
   end
 
   context "pool" do
@@ -51,15 +51,15 @@ describe Celluloid::SupervisionGroup, actor_system: :global do
       MyGroup.run!
       sleep 0.001 # startup time hax
 
-      Celluloid::Actor[:example_pool].should be_running
-      Celluloid::Actor[:example_pool].args.should eq ['foo']
-      Celluloid::Actor[:example_pool].size.should be 3
+      expect(Celluloid::Actor[:example_pool]).to be_running
+      expect(Celluloid::Actor[:example_pool].args).to eq ['foo']
+      expect(Celluloid::Actor[:example_pool].size).to be 3
     end
 
     it "allows external access to the internal registry" do
       supervisor = MyGroup.run!
 
-      supervisor[:example].should be_a MyActor
+      expect(supervisor[:example]).to be_a MyActor
     end
   end
 end
diff --git a/spec/celluloid/supervisor_spec.rb b/spec/celluloid/supervisor_spec.rb
index 1c5440c..c00bba3 100644
--- a/spec/celluloid/supervisor_spec.rb
+++ b/spec/celluloid/supervisor_spec.rb
@@ -23,81 +23,81 @@ describe Celluloid::Supervisor, actor_system: :global do
   it "restarts actors when they die" do
     supervisor = Celluloid::Supervisor.supervise(Subordinate, :idle)
     subordinate = supervisor.actors.first
-    subordinate.state.should be(:idle)
+    expect(subordinate.state).to be(:idle)
 
     subordinate.crack_the_whip
-    subordinate.state.should be(:working)
+    expect(subordinate.state).to be(:working)
 
     expect do
       subordinate.crack_the_whip
     end.to raise_exception(SubordinateDead)
     sleep 0.1 # hax to prevent race :(
-    subordinate.should_not be_alive
+    expect(subordinate).not_to be_alive
 
     new_subordinate = supervisor.actors.first
-    new_subordinate.should_not eq subordinate
-    new_subordinate.state.should eq :idle
+    expect(new_subordinate).not_to eq subordinate
+    expect(new_subordinate.state).to eq :idle
   end
 
   it "registers actors and reregisters them when they die" do
     Celluloid::Supervisor.supervise_as(:subordinate, Subordinate, :idle)
     subordinate = Celluloid::Actor[:subordinate]
-    subordinate.state.should be(:idle)
+    expect(subordinate.state).to be(:idle)
 
     subordinate.crack_the_whip
-    subordinate.state.should be(:working)
+    expect(subordinate.state).to be(:working)
 
     expect do
       subordinate.crack_the_whip
     end.to raise_exception(SubordinateDead)
     sleep 0.1 # hax to prevent race :(
-    subordinate.should_not be_alive
+    expect(subordinate).not_to be_alive
 
     new_subordinate = Celluloid::Actor[:subordinate]
-    new_subordinate.should_not eq subordinate
-    new_subordinate.state.should eq :idle
+    expect(new_subordinate).not_to eq subordinate
+    expect(new_subordinate.state).to eq :idle
   end
 
   it "creates supervisors via Actor.supervise" do
     supervisor = Subordinate.supervise(:working)
     subordinate = supervisor.actors.first
-    subordinate.state.should be(:working)
+    expect(subordinate.state).to be(:working)
 
     expect do
       subordinate.crack_the_whip
     end.to raise_exception(SubordinateDead)
     sleep 0.1 # hax to prevent race :(
-    subordinate.should_not be_alive
+    expect(subordinate).not_to be_alive
 
     new_subordinate = supervisor.actors.first
-    new_subordinate.should_not eq subordinate
-    new_subordinate.state.should eq :working
+    expect(new_subordinate).not_to eq subordinate
+    expect(new_subordinate.state).to eq :working
   end
 
   it "creates supervisors and registers actors via Actor.supervise_as" do
     supervisor = Subordinate.supervise_as(:subordinate, :working)
     subordinate = Celluloid::Actor[:subordinate]
-    subordinate.state.should be(:working)
+    expect(subordinate.state).to be(:working)
 
     expect do
       subordinate.crack_the_whip
     end.to raise_exception(SubordinateDead)
     sleep 0.1 # hax to prevent race :(
-    subordinate.should_not be_alive
+    expect(subordinate).not_to be_alive
 
     new_subordinate = supervisor.actors.first
-    new_subordinate.should_not eq subordinate
-    new_subordinate.state.should be(:working)
+    expect(new_subordinate).not_to eq subordinate
+    expect(new_subordinate.state).to be(:working)
   end
 
   it "removes an actor if it terminates cleanly" do
     supervisor = Subordinate.supervise(:working)
     subordinate = supervisor.actors.first
 
-    supervisor.actors.should == [subordinate]
+    expect(supervisor.actors).to eq([subordinate])
 
     subordinate.terminate
 
-    supervisor.actors.should be_empty
+    expect(supervisor.actors).to be_empty
   end
 end
diff --git a/spec/celluloid/thread_handle_spec.rb b/spec/celluloid/thread_handle_spec.rb
index 54e325e..26d66b1 100644
--- a/spec/celluloid/thread_handle_spec.rb
+++ b/spec/celluloid/thread_handle_spec.rb
@@ -8,12 +8,12 @@ describe Celluloid::ThreadHandle do
   it "knows thread liveliness" do
     queue = Queue.new
     handle = Celluloid::ThreadHandle.new(actor_system) { queue.pop }
-    handle.should be_alive
+    expect(handle).to be_alive
 
     queue << :die
 
     sleep 0.01 # hax
-    handle.should_not be_alive
+    expect(handle).not_to be_alive
   end
 
   it "joins to thread handles" do
@@ -21,6 +21,6 @@ describe Celluloid::ThreadHandle do
   end
 
   it "supports passing a role" do
-    Celluloid::ThreadHandle.new(actor_system, :useful) { Thread.current.role.should == :useful }.join
+    Celluloid::ThreadHandle.new(actor_system, :useful) { expect(Thread.current.role).to eq(:useful) }.join
   end
 end
diff --git a/spec/celluloid/uuid_spec.rb b/spec/celluloid/uuid_spec.rb
index 77c48b3..b547618 100644
--- a/spec/celluloid/uuid_spec.rb
+++ b/spec/celluloid/uuid_spec.rb
@@ -6,6 +6,6 @@ describe Celluloid::UUID do
   it "generates unique IDs across the BLOCK_SIZE boundary" do
     upper_bound = U::BLOCK_SIZE * 2 + 10
     uuids = (1..upper_bound).map{ U.generate }
-    uuids.size.should == uuids.uniq.size
+    expect(uuids.size).to eq(uuids.uniq.size)
   end
 end
